# 📝 문제 설명
컴퓨터 바탕화면은 각 칸이 정사각형인 격자판이다. 이때 컴퓨터 바탕화면의 상태를 나타내는 문자열 배열 wallpaper가 주어진다.
<br/>파일들은 바탕화면의 격자칸에 위치하고 바탕화면의 격자점들은 바탕화면의 가장 왼쪽 위를 (0, 0)으로 시작해 (세로 좌표, 가로 좌표)로 표현한다.

<br/>빈칸은 ".", 파일이 있는 칸은 "#"의 값을 가진다. 드래그를 하면 파일들을 선택할 수 있고, 선택된 파일들을 삭제할 수 있다.
<br/>최소한의 거리를 갖는 한 번의 드래그로 모든 파일을 선택해서 한 번에 지우려고 하며 드래그로 파일들을 선택하는 방법은 다음과 같다.

* 드래그는 바탕화면의 격자점 S(lux, luy)를 마우스 왼쪽 버튼으로 클릭한 상태로 격자점 E(rdx, rdy)로 드래그를 할 때, "드래그 한 거리"는 |rdx - lux| + |rdy - luy|로 정의한다.
* 점 S에서 점 E로 드래그를 하면 바탕화면에서 두 격자점을 각각 왼쪽 위, 오른쪽 아래로 하는 직사각형 내부에 있는 모든 파일이 선택된다.

바탕화면의 상태를 나타내는 문자열 배열 wallpaper가 매개변수로 주어질 때 바탕화면의 파일들을 한 번에 삭제하기 위해 최소한의 이동거리를 갖는 드래그의 시작점과 끝점을 담은 정수 배열을 구하라.
<br/><br/>

# 📌 제한 조건
>* 1 <= wallpaper의 길이 <= 50
>* 1 <= wallpaper[i]의 길이 <= 50
>* wallpaper[i][j]는 "#" 또는 "."의 값만 가진다.
>* 바탕화면에는 적어도 하나의 파일이 있다.
<br/>

# ✔️ 문제 해결 방법
## 1. 내가 제출한 코드
```Javascript
function solution(wallpaper) {
    // 가장 왼쪽에 있는 것 = luy
    // 가장 위쪽에 있는 것 = lux
    // 가장 오른쪽에 있는 것 = rdy
    // 가장 아래쪽에 있는 것 = rdx
    
    let [lux, luy, rdx, rdy] = [-1, 50, 0, 0];
    
    wallpaper.forEach((v, i) => {
        let icons = Array.from(v); // [...v] 문자열을 배열로 쪼개는 더 간단한 방법
        icons.forEach((x, j) => {
            if (x === '#') {
                if (lux < 0) lux = i;
                if (luy > j) luy = j;
                rdx = i;
                if (rdy < j) rdy = j;
            }
        })
    })
    
    var answer = [lux, luy, rdx + 1, rdy + 1];
    return answer;
}
```
바탕화면에 있는 전체 파일들을 드래그하는 데 가장 최소한의 드래그 길이를 구하는 문제이지만,
<br/>사실상 #이 있는 위치의 가장 큰 인덱스 값과 가장 작은 인덱스 값을 구하면 되는 간단한 문제이다.

>드래그 시작점의 X좌표인 lux는 wallpaper[i] 중에 #이 가장 먼저 나오는 i의 값을 구하면 된다.
><br/>드래그 시작점의 Y좌표인 luy는 wallpaper[i][j] 중에 #이 가장 먼저 나오는 j의 값을 구하면 된다.
><br/>드래그 끝점의 X좌표인 rdx는 wallpaper[i] 중에 #이 가장 마지막에 나오는 i의 값을 구하면 된다.
><br/>드래그 끝점의 Y좌표인 rdy는 wallpaper[i][j] 중에 #이 가장 마지막에 나오는 j의 값을 구하면 된다.

위와 같은 방식으로 #의 최대/최소 인덱스 값을 구해주면 드래그 시작점과 끝점의 좌표를 간단하게 구할 수 있다.
<br/>다른 사람들의 풀이를 보며 느꼈던 점은 if문을 쓰지 않고 Math 함수를 썼더라면
<br/>조금 더 깔끔한 풀이를 할 수 있지 않았을까 하는 아쉬움과 문자열을 배열로 쪼갤 때 Array.from()이 아닌
<br/>[...v]와 같은 형태로 쪼갤 수도 있구나라는 점이다.
<br/><br/>

# 참고 사항
출처 - [프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/161990)